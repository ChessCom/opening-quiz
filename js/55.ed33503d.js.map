{"version":3,"file":"js/55.ed33503d.js","mappings":"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","sources":["webpack://opening-quiz/../../src/chessboard/plugins/custom-items/config/types.ts","webpack://opening-quiz/../../src/chessboard/model/board/get-file-rank-from-san.ts","webpack://opening-quiz/../../src/chessboard/modes/model/extend-mode.ts","webpack://opening-quiz/../../src/chessboard/modes/model/create-mode.ts","webpack://opening-quiz/../../src/chessboard/modes/capture-the-star/config/types.ts","webpack://opening-quiz/../../src/chessboard/modes/capture-the-star/api/configure-items.ts","webpack://opening-quiz/../../src/chessboard/modes/capture-the-star/api/get-current-move-count.ts","webpack://opening-quiz/../../src/chessboard/modes/capture-the-star/api/get-data.ts","webpack://opening-quiz/../../src/chessboard/modes/capture-the-star/api/get-items.ts","webpack://opening-quiz/../../src/chessboard/modes/capture-the-star/api/get-item-squares.ts","webpack://opening-quiz/../../src/chessboard/modes/capture-the-star/config/error-messages.ts","webpack://opening-quiz/../../src/chessboard/modes/capture-the-star/model/get-intermediate-squares.ts","webpack://opening-quiz/../../src/chessboard/modes/capture-the-star/api/get-next-items.ts","webpack://opening-quiz/../../src/chessboard/modes/capture-the-star/api/get-num-items-remaining.ts","webpack://opening-quiz/../../src/chessboard/modes/capture-the-star/api/is-completed.ts","webpack://opening-quiz/../../src/chessboard/modes/capture-the-star/model/create-cts-marking.ts","webpack://opening-quiz/../../src/chessboard/modes/capture-the-star/api/load.ts","webpack://opening-quiz/../../src/chessboard/modes/capture-the-star/api/reset-puzzle-status.ts","webpack://opening-quiz/../../src/chessboard/modes/capture-the-star/api/update-puzzle-status.ts","webpack://opening-quiz/../../src/chessboard/modes/capture-the-star/api/index.ts","webpack://opening-quiz/../../src/chessboard/modes/capture-the-star/api-overrides/get-legal-moves/build-fen.ts","webpack://opening-quiz/../../src/utils/array/deduplicate-by-key.ts","webpack://opening-quiz/../../src/chessboard/modes/capture-the-star/api-overrides/get-legal-moves/index.ts","webpack://opening-quiz/../../src/chessboard/modes/capture-the-star/api-overrides/get-move.ts","webpack://opening-quiz/../../src/chessboard/modes/capture-the-star/api-overrides/move.ts","webpack://opening-quiz/../../src/chessboard/modes/capture-the-star/api-overrides/move-backward.ts","webpack://opening-quiz/../../src/chessboard/modes/capture-the-star/plugin/index.ts","webpack://opening-quiz/../../src/chessboard/modes/capture-the-star/base.ts","webpack://opening-quiz/../../src/chessboard/modes/capture-the-star/index.ts","webpack://opening-quiz/../../src/chessboard/model/modes/handle-illegal-move.ts","webpack://opening-quiz/../../src/chessboard/model/game/get-color-as-letter.ts"],"sourcesContent":["import type { Markings } from 'chessboard/plugins/markings/config/types';\n\nexport namespace CustomItems {\n  export interface API {\n    getDefaultStarColor(): string;\n  }\n\n  export namespace Plugin {\n    export const Name = 'custom-items';\n  }\n\n  export enum Classes {\n    Root = 'custom-item',\n  }\n}\n\nexport const CustomItemType = 'customItem';\n\nexport type CustomItemParams = {\n  data: CustomItemData;\n  type: typeof CustomItemType;\n};\n\nexport type CustomItem = Markings.Model & CustomItemParams;\n\nexport type KeyedCustomItem = Markings.KeyedModel & CustomItemParams;\n\nexport type CustomItemData = Markings.WithSquare &\n  Partial<Markings.WithOpacity> &\n  Partial<Markings.WithColor> & {\n    image?: ImageOptions;\n    text?: TextOptions;\n    type: Types;\n    visualOrder?: VisualOrder.Model;\n    frame?: Frame;\n    removalClass?: string;\n    removalSound?: string;\n    removalTimeout?: number;\n  };\n\nexport interface ImageOptions {\n  percentOfSquare?: number;\n  url: string;\n}\n\nexport interface TextOptions {\n  color?: string;\n  value: string;\n}\n\nexport interface Frame {\n  imageURL: string;\n  imageAnimated?: boolean;\n  positionRatioX: number;\n  positionRatioY: number;\n  widthRatio: number;\n  heightRatio: number;\n}\n\nexport namespace VisualOrder {\n  export interface Model {\n    position?: Positions;\n    target: Targets;\n  }\n\n  export const enum Targets {\n    Arrows = 'arrows',\n    Effects = 'effects',\n    Pieces = 'pieces',\n  }\n\n  export const enum Positions {\n    Above = 'above',\n    Below = 'below',\n  }\n}\n\nexport enum Types {\n  Image = 'Image',\n  Star = 'Star',\n  TextBox = 'TextBox',\n}\n","import type { Board } from 'chessboard/model/board/types';\n\n/**\n * Get a fileRank from a SanSquare.\n */\nexport function getFileRankFromSan(san: Board.SanSquare): Board.FileRank {\n  return {\n    file: san.toLowerCase().charCodeAt(0) - 96,\n    rank: Number(san.charAt(1)),\n  };\n}\n","import type { API } from 'api/config/types';\nimport type { Modes } from 'modes/config/types';\n\n/**\n * Extend or override a mode's api.\n */\nexport function createExtendMode(mode: Modes.API.Base, api: API.ExtendedAPI) {\n  return function extendMode(extensions: Record<string, Function>) {\n    const destroyOverrides: (Function | undefined)[] = Object.entries(extensions).map(\n      ([key, fn]) => {\n        if (!fn || !mode.overridableMethods?.includes(key)) {\n          return;\n        }\n\n        const cachedMethod = mode[key];\n\n        mode[key] = fn(mode, api);\n\n        return function destroyOverride() {\n          mode[key] = cachedMethod;\n        };\n      },\n    );\n\n    return function destroyOverride() {\n      destroyOverrides.map((fn) => fn?.());\n    };\n  };\n}\n","import type { API } from 'chessboard/api/config/types';\nimport { Core } from 'chessboard/core/config/types';\nimport { createCoreEvent } from 'chessboard/core/model/create-core-event';\nimport type { Modes } from 'modes/config/types';\nimport { createExtendMode } from 'modes/model/extend-mode';\n\ntype Model<T extends Modes.Options.Initial.Custom> = Modes.Options.Initial.Model<T>;\n\n/**\n * Build a mode.\n */\nfunction buildMode<T extends Modes.Options.Initial.Custom>({\n  base,\n  initialOptions,\n}: {\n  base: Modes.CreateMode.Base<Modes.Options.Exposed.Model<T>>;\n  initialOptions: Model<T>;\n}): Modes.CreateMode.Builder<T> {\n  return function getBoundMode(api: API.ExtendedAPI): Modes.API.Extended<T> {\n    const options = Object.keys(initialOptions).reduce(\n      (acc, key: keyof Model<T>) => {\n        acc[key] = initialOptions[key].default;\n\n        return acc;\n      },\n      {} as Modes.Options.Exposed.Model<T>,\n    );\n\n    const modeAPI = base({ api, options });\n    const extendMode = createExtendMode(modeAPI, api);\n\n    return Object.assign(modeAPI, { extendMode, getOptions, setOption });\n\n    /**\n     * Get the mode options.\n     */\n    function getOptions(): Modes.Options.Exposed.Model<T> {\n      return options;\n    }\n\n    /**\n     * Set an option, if the mode allows setting that option.\n     */\n    function setOption(key: keyof Model<T>, value: boolean) {\n      if (!initialOptions[key]?.editable) {\n        warnOptionNotEditable(key);\n        return;\n      }\n\n      options[key] = value;\n\n      api.emit(\n        Core.OptionsEvents.UpdateMode,\n        createCoreEvent(Core.OptionsEvents.UpdateMode, { [key]: value }),\n      );\n    }\n  };\n}\n\n/**\n * Create a mode, returning the mode itself and a function that enables\n * re-instantiating the mode with new options.\n */\nexport function createModeFactory<T extends Modes.Options.Initial.Custom>(\n  base: Modes.CreateMode.Base<Modes.Options.Exposed.Model<T>>,\n  defaults: Model<T>,\n) {\n  return function createMode(\n    options: Partial<Modes.Options.Exposed.Model<T>> = {},\n  ): Modes.CreateMode.Builder<T> {\n    const initialOptions = Object.keys(options).reduce((acc, key: keyof Model<T>) => {\n      if (defaults[key]?.editable) {\n        Object.assign(acc, { [key]: { default: options[key], editable: true } });\n      } else {\n        warnOptionNotEditable(key);\n      }\n\n      return acc;\n    }, defaults);\n\n    return buildMode({\n      base,\n      initialOptions,\n    });\n  };\n}\n\n/**\n * Warn the developer that an option is not editable.\n */\nfunction warnOptionNotEditable<T>(key: keyof T) {\n  //@ts-ignore\n  console.warn(`${key} is not an editable option in this mode.`); // eslint-disable-line\n}\n","import type { EventEmitterUtil } from '@chesscom/web-ui';\nimport type { API } from 'api/config/types';\nimport type { Game } from 'chessboard/model/game/types';\nimport type { KeyedCustomItem } from 'chessboard/plugins/custom-items/config/types';\nimport type JCE from '@chesscom/js-chess-engine';\n\nexport namespace CaptureTheStar {\n  export interface API extends EventEmitterUtil.EventEmitter {\n    configureItems(items: ItemsObj): void;\n    getCurrentMoveCount(): number;\n    getData(): CaptureTheStar.Data;\n    getItems(options?: { previousNode?: boolean }): KeyedCustomItem[];\n    getItemSquares(): JCE.SanSquare[];\n    getNextItems(move: Game.Move.Model): KeyedCustomItem[];\n    getNumItemsRemaining(): number;\n    isCompleted(): boolean;\n    load(params: LoadParams): API.Response;\n    resetPuzzleStatus(): void;\n    updatePuzzleStatus(): void;\n  }\n\n  export interface Config {\n    items: ItemsObj;\n  }\n\n  export type ConfigMap = Map<keyof Config, Config[keyof Config]>;\n\n  export interface Data extends Status {\n    itemsRemaining: number;\n    moveCount: number;\n  }\n\n  export const enum Events {\n    Completed = 'CTSCompleted',\n  }\n\n  export interface InternalAPI {\n    config: ConfigMap;\n    status: StatusMap;\n  }\n\n  export type ItemsObj = Record<string, string>;\n\n  export interface LoadParams {\n    items: Partial<Record<JCE.SanSquare, string>>;\n    piece: JCE.Piece.WithSanSquare;\n  }\n\n  export namespace Plugin {\n    export const Name = 'captureTheStar';\n  }\n\n  export interface Status {\n    completed: boolean;\n    completedMoveCount?: number;\n  }\n\n  export type StatusMap = Map<keyof Status, Status[keyof Status]>;\n}\n","import type { CaptureTheStar } from '../config/types';\n\n/**\n * Create the configureItems method.\n */\nexport function createConfigureitems(internalAPI: CaptureTheStar.InternalAPI) {\n  /**\n   * Configure the items for CTS.\n   */\n  return function configureItems(items: CaptureTheStar.ItemsObj): void {\n    internalAPI.config.set('items', items);\n  };\n}\n","import type { API } from 'api/config/types';\n\n/**\n * Create the getCurrentMoveCount method.\n */\nexport function createGetCurrentMoveCount(api: API.ExtendedAPI) {\n  /**\n   * Get the current move count.\n   */\n  return function getCurrentMoveCount(): number {\n    return api.getHistorySANs()?.length - 1 || 0;\n  };\n}\n","import type { API } from 'api/config/types';\nimport type { CaptureTheStar } from 'chessboard/modes/capture-the-star/config/types';\n\n/**\n * Create the getData method.\n */\nexport function createGetData(api: API.ExtendedAPI, internalAPI: CaptureTheStar.InternalAPI) {\n  /**\n   * Get the current Capture the Star data.\n   */\n  return function getData(): CaptureTheStar.Data {\n    const cts = <CaptureTheStar.API>api.captureTheStar;\n\n    return {\n      completed: <boolean | undefined>internalAPI.status.get('completed') || false,\n      completedMoveCount: <number | undefined>internalAPI.status.get('completedMoveCount'),\n      itemsRemaining: cts.getNumItemsRemaining(),\n      moveCount: cts.getCurrentMoveCount(),\n    };\n  };\n}\n","import type { API } from 'api/config/types';\nimport type { KeyedCustomItem } from 'chessboard/plugins/custom-items/config/types';\nimport { CustomItemType } from 'chessboard/plugins/custom-items/config/types';\nimport type { Markings } from 'chessboard/plugins/markings/config/types';\n\n/**\n * Create the getItems method.\n */\nexport function createGetItems(context: API.Context) {\n  /**\n   * Get all items on the board, either for the current or previous.\n   */\n  return function getItems(options: { previousNode?: boolean } = {}): KeyedCustomItem[] {\n    const { api, game } = context;\n    const markings = <Markings.API>api.markings;\n    const { previousNode } = options;\n\n    let items: KeyedCustomItem[] = [];\n\n    if (previousNode) {\n      // Cache the current ids\n      const ids = game.ids();\n\n      // Select the target node\n      game.moveBackward();\n\n      items = getItems();\n\n      // Revert to the original position\n      game.selectPosition(ids.move, ids.line);\n    } else {\n      items = <KeyedCustomItem[]>markings.getAllWhere({ types: [CustomItemType] });\n    }\n\n    return items;\n  };\n}\n","import type { API } from 'api/config/types';\nimport type { CaptureTheStar } from 'chessboard/modes/capture-the-star/config/types';\nimport type JCE from '@chesscom/js-chess-engine';\n\n/**\n * Create the getItemSquares method.\n */\nexport function createGetItemSquares(api: API.ExtendedAPI) {\n  /**\n   * Get all the squares that contain items.\n   */\n  return function getItemSquares(): JCE.SanSquare[] {\n    const cts = <CaptureTheStar.API>api.captureTheStar;\n\n    return cts.getItems().map((item) => item.data.square);\n  };\n}\n","export const errorMessages = {\n  noFromSquareOnMoveObj: 'Move object has no \"from\" square.',\n  cannotLoadWithoutItems: 'Cannot load without any items.',\n  cannotLoadWithoutPiece: 'Cannot load without a piece.',\n  configurationMissingForItem: 'Configuration missing for custom item',\n};\n","import { getFileRankFromSan } from 'chessboard/model/board/get-file-rank-from-san';\nimport type JCE from '@chesscom/js-chess-engine';\n\n/**\n * Get intermediate squares between two squares.\n */\nexport function getIntermediateSquares(from: JCE.SanSquare, to: JCE.SanSquare): JCE.SanSquare[] {\n  const { file: fromFile, rank: fromRank } = getFileRankFromSan(from);\n  const { file: toFile, rank: toRank } = getFileRankFromSan(to);\n\n  const files = 'abcdefgh';\n  const ranks = '12345678';\n\n  if (fromFile === toFile) {\n    return <JCE.SanSquare[]>(\n      getIntegersBetweenTwoNumbers(fromRank, toRank).map(\n        (rank) => `${files.charAt(fromFile - 1)}${ranks.charAt(rank - 1)}`,\n      )\n    );\n  }\n\n  if (fromRank === toRank) {\n    return <JCE.SanSquare[]>(\n      getIntegersBetweenTwoNumbers(fromFile, toFile).map(\n        (file) => `${files.charAt(file - 1)}${ranks.charAt(fromRank - 1)}`,\n      )\n    );\n  }\n\n  if (Math.abs(toFile - fromFile) !== Math.abs(toRank - fromRank)) {\n    throw new Error('Squares are not on same file, rank, or diagonal');\n  }\n\n  const intermediateFiles = getIntegersBetweenTwoNumbers(fromFile, toFile);\n  const intermediateRanks = getIntegersBetweenTwoNumbers(fromRank, toRank);\n\n  return intermediateFiles.reduce(\n    (acc, cur, ndx) => {\n      acc.push(\n        <JCE.SanSquare>`${files.charAt(cur - 1)}${ranks.charAt(intermediateRanks[ndx] - 1)}`,\n      );\n\n      return acc;\n    },\n    <JCE.SanSquare[]>[],\n  );\n}\n\n/**\n * Get an array of all integers between two numbers.\n */\nfunction getIntegersBetweenTwoNumbers(first: number, second: number) {\n  const [start, end] = [first, second].sort();\n\n  return Array(end - start - 1)\n    .fill(undefined)\n    .map((_val, ndx) => start + ndx + 1);\n}\n","import type { API } from 'api/config/types';\nimport type { CaptureTheStar } from 'chessboard/modes/capture-the-star/config/types';\nimport { errorMessages } from 'chessboard/modes/capture-the-star/config/error-messages';\nimport type { Game } from 'chessboard/model/game/types';\nimport { getIntermediateSquares } from 'chessboard/modes/capture-the-star/model/get-intermediate-squares';\nimport type { KeyedCustomItem } from 'chessboard/plugins/custom-items/config/types';\nimport type JCE from '@chesscom/js-chess-engine';\n\n/**\n * Create the getNextItems method.\n */\nexport function createGetNextItems(api: API.ExtendedAPI) {\n  /**\n   * Get the next items after a move.\n   */\n  return function getNextItems(move: Game.Move.Model): KeyedCustomItem[] {\n    const cts = <CaptureTheStar.API>api.captureTheStar;\n    const { from, to } = move;\n\n    if (!from) {\n      throw new Error(errorMessages.noFromSquareOnMoveObj);\n    }\n\n    let allMoveSquares: JCE.SanSquare[] = [];\n\n    // Calculate the number of squares to clear, including the \"to\" square.\n    if (move.piece.toLowerCase() === 'n') {\n      allMoveSquares = [to];\n    } else {\n      allMoveSquares = [to, ...getIntermediateSquares(from, to)];\n    }\n\n    // This handler is in response to the Move event, which means that the\n    // JCE game has already moved onto the new node. Therefore, we need to\n    // copy the PREVIOUS node's markings over to this node (minus the\n    // captured items).\n    return cts\n      .getItems({ previousNode: true })\n      .filter((item) => !allMoveSquares.includes(item.data.square));\n  };\n}\n","import type { API } from 'api/config/types';\nimport type { CaptureTheStar } from 'chessboard/modes/capture-the-star/config/types';\n\n/**\n * Create the getNumItemsRemaining method.\n */\nexport function createGetNumItemsRemaining(api: API.ExtendedAPI) {\n  /**\n   * Get the number of items remaining on the board.\n   */\n  return function getNumItemsRemaining(): number {\n    const cts = <CaptureTheStar.API>api.captureTheStar;\n\n    return Object.keys(cts.getItems()).length;\n  };\n}\n","import type { CaptureTheStar } from 'chessboard/modes/capture-the-star/config/types';\n\n/**\n * Create the isCompleted method.\n */\nexport function createIsCompleted(internalAPI: CaptureTheStar.InternalAPI) {\n  /**\n   * Return whether or not the current puzzle is completed.\n   */\n  return function isCompleted(): boolean {\n    return Boolean(internalAPI.status.get('completed'));\n  };\n}\n","import type { CaptureTheStar } from 'chessboard/modes/capture-the-star/config/types';\nimport type JCE from '@chesscom/js-chess-engine';\nimport type { CustomItem, KeyedCustomItem } from 'chessboard/plugins/custom-items/config/types';\nimport { CustomItemType, Types } from 'chessboard/plugins/custom-items/config/types';\n\n/**\n * Create a marking for Capture the Star.\n */\nexport function createCTSMarking(\n  items: CaptureTheStar.Config['items'] | undefined,\n  square: JCE.SanSquare,\n  item: Types,\n): CustomItem | null {\n  const itemURL = items?.[item];\n\n  if (!Types[item] && !itemURL) {\n    return null;\n  }\n\n  const marking: KeyedCustomItem = {\n    data: {\n      square,\n      type: itemURL ? Types.Image : Types.Star,\n    },\n    node: true,\n    persistent: true,\n    type: CustomItemType,\n    key: `cts-${square}`,\n  };\n\n  if (itemURL) {\n    marking.data.image = { url: itemURL };\n  }\n\n  return marking;\n}\n","import type { API } from 'api/config/types';\nimport type { CaptureTheStar } from 'chessboard/modes/capture-the-star/config/types';\nimport { Core } from 'chessboard/core/config/types';\nimport { createCTSMarking } from 'chessboard/modes/capture-the-star/model/create-cts-marking';\nimport { errorMessages } from 'chessboard/modes/capture-the-star/config/error-messages';\nimport type { Markings } from 'chessboard/plugins/markings/config/types';\nimport type { Types } from 'chessboard/plugins/custom-items/config/types';\nimport type JCE from '@chesscom/js-chess-engine';\n\n/**\n * Create the load method.\n */\nexport function createLoad(context: API.Context, internalAPI: CaptureTheStar.InternalAPI) {\n  /**\n   * Load a new puzzle.\n   */\n  return function load(params: CaptureTheStar.LoadParams): API.Response {\n    const { items: newItems, piece: newPiece } = params;\n    const { api, game, respond } = context;\n    const cts = <CaptureTheStar.API>api.captureTheStar;\n    const markings = <Markings.API>api.markings;\n\n    if (!Object.keys(newItems).length) {\n      throw new Error(errorMessages.cannotLoadWithoutItems);\n    }\n\n    if (!newPiece) {\n      throw new Error(errorMessages.cannotLoadWithoutPiece);\n    }\n\n    api.clearMarkings();\n    game.load('8/8/8/8/8/8/8/8');\n    game.put(newPiece, newPiece.square);\n\n    (<[JCE.SanSquare, string][]>Object.entries(newItems)).forEach(([square, item]) => {\n      const marking = createCTSMarking(internalAPI.config.get('items'), square, <Types>item);\n\n      if (!marking) {\n        throw new Error(errorMessages.configurationMissingForItem);\n      }\n\n      markings.addOne(marking);\n    });\n\n    api.setPlayingAs(newPiece.color);\n    api.setTurn(newPiece.color);\n\n    cts.resetPuzzleStatus();\n\n    return respond(Core.APIEvents.Load, {\n      pieces: api.getPieces(),\n    });\n  };\n}\n","import type { CaptureTheStar } from 'chessboard/modes/capture-the-star/config/types';\n\n/**\n * Create the resetStatus method.\n */\nexport function createResetPuzzleStatus(internalAPI: CaptureTheStar.InternalAPI) {\n  /**\n   * Reset the status.\n   */\n  return function resetPuzzleStatus(): void {\n    internalAPI.status.set('completed', false);\n    internalAPI.status.delete('completedMoveCount');\n  };\n}\n","import type { API } from 'api/config/types';\nimport { CaptureTheStar } from 'chessboard/modes/capture-the-star/config/types';\n\n/**\n * Create the updatePuzzleStatus method.\n */\nexport function createUpdatePuzzleStatus(\n  api: API.ExtendedAPI,\n  internalAPI: CaptureTheStar.InternalAPI,\n) {\n  /**\n   * Update the puzzle status.\n   */\n  return function updatePuzzleStatus(): void {\n    const cts = <CaptureTheStar.API>api.captureTheStar;\n\n    if (cts.getNumItemsRemaining() === 0 && !cts.isCompleted()) {\n      internalAPI.status.set('completed', true);\n      internalAPI.status.set('completedMoveCount', cts.getCurrentMoveCount());\n\n      cts.emit(CaptureTheStar.Events.Completed, cts.getData());\n    }\n  };\n}\n","import type { API } from 'api/config/types';\nimport type { CaptureTheStar } from 'chessboard/modes/capture-the-star/config/types';\nimport { createConfigureitems } from 'chessboard/modes/capture-the-star/api/configure-items';\nimport { EventEmitterUtil } from '@chesscom/web-ui';\nimport { createGetCurrentMoveCount } from 'chessboard/modes/capture-the-star/api/get-current-move-count';\nimport { createGetData } from 'chessboard/modes/capture-the-star/api/get-data';\nimport { createGetItems } from 'chessboard/modes/capture-the-star/api/get-items';\nimport { createGetItemSquares } from 'chessboard/modes/capture-the-star/api/get-item-squares';\nimport { createGetNextItems } from 'chessboard/modes/capture-the-star/api/get-next-items';\nimport { createGetNumItemsRemaining } from 'chessboard/modes/capture-the-star/api/get-num-items-remaining';\nimport { createIsCompleted } from 'chessboard/modes/capture-the-star/api/is-completed';\nimport { createLoad } from 'chessboard/modes/capture-the-star/api/load';\nimport { createResetPuzzleStatus } from 'chessboard/modes/capture-the-star/api/reset-puzzle-status';\nimport { createUpdatePuzzleStatus } from 'chessboard/modes/capture-the-star/api/update-puzzle-status';\n\nconst { createEventEmitter } = EventEmitterUtil;\n\n/**\n * Create the Capture the Star API.\n */\nexport function createCaptureTheStarAPI(context: API.Context): CaptureTheStar.API {\n  const { api } = context;\n\n  const emitter = createEventEmitter();\n  const internalAPI = createInternalAPI();\n\n  internalAPI.config.set('items', {});\n\n  const resetPuzzleStatus = createResetPuzzleStatus(internalAPI);\n\n  resetPuzzleStatus();\n\n  return {\n    configureItems: createConfigureitems(internalAPI),\n    getCurrentMoveCount: createGetCurrentMoveCount(api),\n    getData: createGetData(api, internalAPI),\n    getItems: createGetItems(context),\n    getItemSquares: createGetItemSquares(api),\n    getNextItems: createGetNextItems(api),\n    getNumItemsRemaining: createGetNumItemsRemaining(api),\n    ...emitter,\n    isCompleted: createIsCompleted(internalAPI),\n    load: createLoad(context, internalAPI),\n    resetPuzzleStatus,\n    updatePuzzleStatus: createUpdatePuzzleStatus(api, internalAPI),\n  };\n\n  /**\n   * Create an API for internal use.\n   */\n  function createInternalAPI(): CaptureTheStar.InternalAPI {\n    const config: CaptureTheStar.ConfigMap = new Map();\n    const status: CaptureTheStar.StatusMap = new Map();\n\n    return {\n      config,\n      status,\n    };\n  }\n}\n","import { getColorAsLetter } from 'chessboard/model/game/get-color-as-letter';\nimport { getFileRankFromSan } from 'chessboard/model/board/get-file-rank-from-san';\nimport { getOppositeColor } from 'chessboard/model/game/get-opposite-color';\nimport { Game } from 'chessboard/model/game/types';\nimport type JCE from '@chesscom/js-chess-engine';\n\n/**\n * Convert an array of squares to a FEN.\n */\nexport function buildFEN(\n  squares: JCE.SanSquare[],\n  piece: JCE.Piece.WithFileRank,\n  playingAs: Game.ColorsAsNumbers,\n) {\n  const opponentPieceShortString =\n    getOppositeColor(piece.color) === Game.ColorsAsNumbers.Black ? 'p' : 'P';\n  const userPieceShortString =\n    piece.color === Game.ColorsAsNumbers.Black ? piece.type : piece.type.toUpperCase();\n  const board = new Array(8).fill(undefined).map(() => new Array(8).fill('.'));\n\n  board[8 - piece.rank][piece.file - 1] = userPieceShortString;\n\n  return squares\n    .reduce((acc, cur) => {\n      const { file, rank } = getFileRankFromSan(cur);\n\n      if (!file || !rank) {\n        return acc;\n      }\n\n      acc[8 - rank][file - 1] = opponentPieceShortString;\n\n      return acc;\n    }, board)\n    .map((rank) => rank.join('').replace(/(\\.+)/g, (m) => m.length.toString()))\n    .join('/')\n    .concat(` ${getColorAsLetter(playingAs)}`);\n}\n","/**\n * Deduplicate an array by a specific property on that array.\n */\nexport function deduplicateByKey<T>(arr: T[], key: string): T[] {\n  return [...new Map(arr.map((item) => [item[key], item])).values()];\n}\n","import type { API } from 'chessboard/api/config/types';\nimport { buildFEN } from 'chessboard/modes/capture-the-star/api-overrides/get-legal-moves/build-fen';\nimport type { CaptureTheStar } from 'chessboard/modes/capture-the-star/config/types';\nimport { deduplicateByKey } from 'src/utils/array/deduplicate-by-key';\nimport type { Game } from 'chessboard/model/game/types';\nimport JCE from '@chesscom/js-chess-engine';\n\n/**\n * Create the getLegalMoves override.\n */\nexport function createGetLegalMoves(context: API.Context): API.ExtendedAPI['getLegalMoves'] {\n  const { api, game } = context;\n  const originalMethod = api.getLegalMoves;\n\n  /**\n   * Override the getLegalMoves method. Given that stars can be captured by pawns both\n   * diagonally and forward, we use an alternative JCE instance where stars are treated as\n   * opponent pawns, thereby allowing us to calculate diagonal captures.\n   */\n  return function getLegalMoves(): Game.Move.Model[] {\n    const cts = <CaptureTheStar.API>api.captureTheStar;\n    const playingAs = api.getPlayingAs();\n\n    if (!playingAs) {\n      return [];\n    }\n\n    const mainGameLegalMoves = originalMethod();\n\n    // Get the piece from the board. There is only one piece, so we just get the first.\n    const piece = game.getPieces(false)[0];\n\n    // If the Capture the Star piece is not a pawn, we can just use the\n    if (!piece || piece.type !== 'p') {\n      return mainGameLegalMoves;\n    }\n\n    // Create a FEN that swaps the stars for opponent pieces, in order to\n    // calculate the legal moves.\n    const fen = buildFEN(cts.getItemSquares(), piece, playingAs);\n\n    const legalMoves = JCE.getLegalMoves(fen);\n\n    // Before returning, concatenate the arrays and remove duplicated moves.\n    return deduplicateByKey([...mainGameLegalMoves, ...legalMoves], 'san');\n  };\n}\n","import type { API } from 'chessboard/api/config/types';\nimport type { Game } from 'chessboard/model/game/types';\nimport type JCE from '@chesscom/js-chess-engine';\n\n/**\n * Create the getMove override.\n */\nexport function createGetMove(context: API.Context): API.ExtendedAPI['getMove'] {\n  const { api } = context;\n  const originalMethod = api.getMove;\n\n  /**\n   * Override the getMove method. Here, extra moves are available because pawns\n   * can capture diagonally in CTS.\n   */\n  return function getMove(mv: JCE.AnyMoveType): Game.Move.Model | null {\n    const move = originalMethod(mv);\n\n    if (move) {\n      return move;\n    }\n\n    return api.getLegalMoves().find((legalMove) => legalMove.to === mv.to) ?? null;\n  };\n}\n","import { formatAPIMove } from 'api/move/model/format-api-move';\nimport type { API } from 'chessboard/api/config/types';\nimport { getOppositeColor } from 'chessboard/model/game/get-opposite-color';\nimport { isCapture } from 'chessboard/model/move/is-capture';\n\n/**\n * Create the move override.\n */\nexport function createMove(context: API.Context): API.ExtendedAPI['move'] {\n  const { api, game } = context;\n  const originalMethod = api.move;\n\n  /**\n   * Override the move method.\n   */\n  return function move(mv: API.Options.Move | string) {\n    if (!api.isAtEndOfLine()) {\n      return api.selectLineEnd();\n    }\n\n    const formattedMove = formatAPIMove(mv, api.getFEN(), api.getVariant());\n\n    if (!formattedMove || !formattedMove.userGenerated || !('flags' in formattedMove)) {\n      return originalMethod(mv);\n    }\n\n    // If it's a user-generated move, we need to handle one specific edge-case. If the\n    // move is a diagonal pawn capture, then we need to place that pawn on\n    // the board before it's captured. This is so that JCE can record\n    // the move correctly.\n    const isDiagonalPawnCapture = isCapture(formattedMove) && formattedMove.piece === 'p';\n\n    if (isDiagonalPawnCapture) {\n      game.put({ type: 'p', color: getOppositeColor(formattedMove.color) }, formattedMove.to);\n    }\n\n    return originalMethod(mv);\n  };\n}\n","import type { API } from 'chessboard/api/config/types';\nimport { Core } from 'chessboard/core/config/types';\n\n/**\n * Create the moveBackward override.\n */\nexport function createMoveBackward(context: API.Context) {\n  return function moveBackward(): API.Response {\n    const { respond, game, mutateGame } = context;\n\n    const data = mutateGame(function callMethod() {\n      game.moveBackward();\n    });\n\n    if (!data || (data.lineDiff === 0 && data.plyDiff === 0)) {\n      return respond(Core.APIEvents.MoveBackward, null);\n    }\n\n    // This is the key difference. If we remove the `captured` property\n    // then the renderer won't try to place the piece.\n    if (data.move?.captured) {\n      data.move.captured = undefined;\n    }\n\n    return respond(Core.APIEvents.MoveBackward, data);\n  };\n}\n","import { CaptureTheStar } from 'chessboard/modes/capture-the-star/config/types';\nimport { Core } from 'chessboard/core/config/types';\nimport { createCaptureTheStarAPI } from 'chessboard/modes/capture-the-star/api';\nimport { createGetLegalMoves } from 'chessboard/modes/capture-the-star/api-overrides/get-legal-moves';\nimport { createGetMove } from 'chessboard/modes/capture-the-star//api-overrides/get-move';\nimport { createMove } from 'chessboard/modes/capture-the-star//api-overrides/move';\nimport { createMoveBackward } from 'chessboard/modes/capture-the-star//api-overrides/move-backward';\nimport { is } from 'src/utils/app/model/is';\nimport { isOneOf } from 'src/utils/app/model/is-one-of';\nimport type { Plugins } from 'chessboard/core/plugins/config/types';\nimport { positionChangeEvents } from 'chessboard/config/position-change-events';\nimport type { Markings } from 'plugins/markings/config/types';\n\n/**\n * Create the Capture the Star plugin.\n *\n * NB: this is not for public consumption - only to be added by the CTS mode.\n */\nexport function createCaptureTheStarPlugin(config?: CaptureTheStar.Config): Plugins.Model {\n  return {\n    api: createCaptureTheStarAPI,\n    apiOverrides: {\n      getLegalMoves: createGetLegalMoves,\n      getMove: createGetMove,\n      move: createMove,\n      moveBackward: createMoveBackward,\n    },\n    create,\n    match: [\n      { condition: isOneOf(positionChangeEvents), handler: setTurn },\n      { condition: is(Core.APIEvents.Move), handler: handleMove },\n    ],\n    name: CaptureTheStar.Plugin.Name,\n  };\n\n  /**\n   * Set the initial config.\n   */\n  function create(context: Core.Context) {\n    const { api } = context;\n    const cts = <CaptureTheStar.API>api.captureTheStar;\n\n    if (config) {\n      cts.configureItems(config.items);\n    }\n  }\n\n  /**\n   * Handle the move event.\n   */\n  function handleMove(event: Core.Event, context: Core.Context) {\n    const { api, queue } = context;\n    const cts = <CaptureTheStar.API>api.captureTheStar;\n    const markings = <Markings.API>api.markings;\n    const game = api.getContext().game;\n\n    const nextItems = cts.getNextItems(event.data.move);\n\n    // JCE move has already happened, so we need to add the new custom items to the CURRENT node.\n    // TODO: add capability for the markings API to add markings to individual nodes\n    // (https://chesscom.atlassian.net/browse/CV-222156)\n    queue.add(function refreshCTS() {\n      queue.add(function refreshInNextCycle() {\n        markings.addMany(nextItems);\n        game.turn(api.getPlayingAs());\n        cts.updatePuzzleStatus();\n      });\n    });\n  }\n\n  /**\n   * Set the turn after every position change.\n   */\n  function setTurn(_event: Core.Event, context: Core.Context) {\n    const { api, queue } = context;\n\n    const playingAs = api.getPlayingAs();\n\n    if (!playingAs) {\n      return;\n    }\n\n    queue.add(api.setTurn, playingAs);\n  }\n}\n","import { createCaptureTheStarPlugin } from 'chessboard/modes/capture-the-star/plugin';\nimport { createHandleIllegalMove } from 'chessboard/model/modes/handle-illegal-move';\nimport { Modes } from 'chessboard/modes/config/types';\n\n/**\n * Create the base observing mode.\n */\nexport function base({ api }: Modes.CreateMode.BaseOptions): Modes.API.Base {\n  return {\n    isAllowedToMove,\n    handleIllegalMove: createHandleIllegalMove(api),\n    name: Modes.Types.CaptureTheStar,\n    plugins: [createCaptureTheStarPlugin()],\n    usePlayingAs: true,\n  };\n\n  /**\n   * Is allowed to move.\n   */\n  function isAllowedToMove(): boolean {\n    return true;\n  }\n}\n","import { createModeFactory } from 'chessboard/modes/model/create-mode';\nimport { base } from 'chessboard/modes/capture-the-star/base';\n\nexport const create = createModeFactory(base, {\n  canAddMovesToMainLine: { default: true, editable: false },\n  canInteractWithPieces: { default: true, editable: true },\n  canModifyExistingMovesOnMainLine: { default: false, editable: false },\n});\n","import type { API } from 'api/config/types';\n\n/**\n * Create mode handler for illegal moves\n */\nexport function createHandleIllegalMove(api: API.ExtendedAPI) {\n  /**\n   * If the user is browsing through the moves, we want any illegal move to send us\n   * back to the head of the line.\n   */\n  return function handleIllegalMove() {\n    if (!api.isAtEndOfLine()) {\n      api.selectLineEnd();\n    }\n  };\n}\n","import { Game } from 'chessboard/model/game/types';\n\n/**\n * Gets the color as a letter, e.g. 'b', 'w'.\n */\nexport function getColorAsLetter(color: Game.ColorsAsNumbers) {\n  return color === Game.ColorsAsNumbers.Black\n    ? Game.ColorsAsLetters.Black\n    : Game.ColorsAsLetters.White;\n}\n"],"names":["CustomItems","CustomItems2","Plugin2","Name","Plugin","Classes2","Classes","CustomItemType","VisualOrder","VisualOrder2","Targets2","Targets","Positions2","Positions","Types","Types2","getFileRankFromSan","san","file","toLowerCase","charCodeAt","rank","Number","charAt","createExtendMode","mode","api","extensions","destroyOverrides","Object","entries","map","key","fn","_a","overridableMethods","includes","cachedMethod","buildMode","base","initialOptions","options","keys","reduce","acc","default","modeAPI","extendMode","assign","getOptions","setOption","value","editable","emit","Core","OptionsEvents","UpdateMode","createCoreEvent","warnOptionNotEditable","createModeFactory","defaults","console","warn","CaptureTheStar","CaptureTheStar2","Events2","Events","createConfigureitems","internalAPI","items","config","set","createGetCurrentMoveCount","getHistorySANs","length","createGetData","cts","captureTheStar","completed","status","get","completedMoveCount","itemsRemaining","getNumItemsRemaining","moveCount","getCurrentMoveCount","createGetItems","context","getItems","game","markings","previousNode","ids","moveBackward","selectPosition","move","line","getAllWhere","types","createGetItemSquares","item","data","square","errorMessages","noFromSquareOnMoveObj","cannotLoadWithoutItems","cannotLoadWithoutPiece","configurationMissingForItem","getIntermediateSquares","from","to","fromFile","fromRank","toFile","toRank","files","ranks","getIntegersBetweenTwoNumbers","Math","abs","Error","intermediateFiles","intermediateRanks","cur","ndx","push","first","second","start","end","sort","Array","fill","_val","createGetNextItems","allMoveSquares","piece","filter","createGetNumItemsRemaining","createIsCompleted","Boolean","createCTSMarking","itemURL","marking","type","Image","Star","node","persistent","image","url","createLoad","params","newItems","newPiece","respond","clearMarkings","load","put","forEach","addOne","setPlayingAs","color","setTurn","resetPuzzleStatus","APIEvents","Load","pieces","getPieces","createResetPuzzleStatus","delete","createUpdatePuzzleStatus","isCompleted","Completed","getData","createEventEmitter","index$e","createCaptureTheStarAPI","emitter","createInternalAPI","configureItems","getItemSquares","getNextItems","updatePuzzleStatus","Map","buildFEN","squares","playingAs","opponentPieceShortString","getOppositeColor","Game","ColorsAsNumbers","Black","userPieceShortString","toUpperCase","board","join","replace","m","toString","concat","getColorAsLetter","deduplicateByKey","arr","values","createGetLegalMoves","originalMethod","getLegalMoves","getPlayingAs","mainGameLegalMoves","fen","legalMoves","JCE","createGetMove","getMove","mv","find","legalMove","createMove","isAtEndOfLine","selectLineEnd","formattedMove","formatAPIMove","getFEN","getVariant","userGenerated","isDiagonalPawnCapture","isCapture","createMoveBackward","mutateGame","lineDiff","plyDiff","MoveBackward","captured","createCaptureTheStarPlugin","apiOverrides","create","match","condition","isOneOf","positionChangeEvents","handler","is","Move","handleMove","name","event","queue","getContext","nextItems","add","addMany","turn","_event","isAllowedToMove","handleIllegalMove","createHandleIllegalMove","Modes","plugins","usePlayingAs","canAddMovesToMainLine","canInteractWithPieces","canModifyExistingMovesOnMainLine","ColorsAsLetters","White"],"sourceRoot":""}