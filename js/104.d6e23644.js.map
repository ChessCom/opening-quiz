{"version":3,"file":"js/104.d6e23644.js","mappings":"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","sources":["webpack://opening-quiz/../../src/chessboard/modes/base/handle-move-on-previous-node-factory.ts","webpack://opening-quiz/../../src/chessboard/modes/playing/config/types.ts","webpack://opening-quiz/../../src/chessboard/modes/playing/api-overrides/move.ts","webpack://opening-quiz/../../src/chessboard/modes/playing/plugin/index.ts","webpack://opening-quiz/../../src/chessboard/modes/playing/model/is-allowed-to-move-in-playing-mode.ts","webpack://opening-quiz/../../src/chessboard/modes/playing/base.ts","webpack://opening-quiz/../../src/chessboard/modes/playing/index.ts","webpack://opening-quiz/../../src/chessboard/modes/model/extend-mode.ts","webpack://opening-quiz/../../src/chessboard/modes/model/create-mode.ts","webpack://opening-quiz/../../src/chessboard/modes/base/get-ids-to-delete.ts","webpack://opening-quiz/../../src/chessboard/model/modes/handle-illegal-move.ts","webpack://opening-quiz/../../src/chessboard/model/game/is-node.ts"],"sourcesContent":["import type { API } from 'chessboard/api/config/types';\nimport { getIdsToDelete } from 'chessboard/modes/base/get-ids-to-delete';\n\n/**\n * If the main line can be modified, and the user makes a move\n * on a previous node, overwrite the subsequent line with that move.\n */\nexport function handleMoveOnPreviousNodeFactory(context: API.Context) {\n  const { api } = context;\n\n  return function handleMoveOnPreviousNode() {\n    if (api.isAtEndOfLine()) {\n      return;\n    }\n\n    if (api.getMode().getOptions().canModifyExistingMovesOnMainLine) {\n      const { line, move } = getIdsToDelete(api.getRelativeNode());\n\n      api.deletePosition(move, line);\n    } else {\n      api.selectLineEnd();\n    }\n  };\n}\n","import type { Modes } from 'modes/config/types';\n\nexport namespace PlayingMode {\n  export type Options = {\n    canMoveWhenGameIsOver: Modes.Options.Initial.Option;\n  };\n\n  export namespace Plugin {\n    export const Name = 'playing';\n  }\n}\n","import type { API } from 'src';\nimport { handleMoveOnPreviousNodeFactory } from 'modes/base/handle-move-on-previous-node-factory';\nimport { Game } from 'chessboard/model/game/types';\n\n/**\n * Check to see if the user can make moves when the game\n * is over, and remove the game over logic if so. Also,\n * handle a potential move on a previous node.\n */\nexport function createBeforeMoveLogic(context: API.Context) {\n  const { api } = context;\n  const handleMoveOnPreviousNode = handleMoveOnPreviousNodeFactory(context);\n\n  return function beforeMove() {\n    if (api.isGameOver() && api.getMode().getOptions().canMoveWhenGameIsOver) {\n      api.setResult(Game.Results.None);\n    }\n\n    handleMoveOnPreviousNode();\n  };\n}\n","import type { Plugins } from 'chessboard/core/plugins/config/types';\nimport { createBeforeMoveLogic } from 'modes/playing/api-overrides/move';\nimport { PlayingMode } from 'modes/playing/config/types';\n\n/**\n * Create a factory for the playing mode's plugin.\n */\nexport function createPlayingModePlugin(): Plugins.Model {\n  return {\n    apiOverrides: {\n      move: { handler: createBeforeMoveLogic, run: 'before', order: 9 },\n    },\n    name: PlayingMode.Plugin.Name,\n  };\n}\n","import type { API } from 'api/config/types';\nimport type { Modes } from 'modes/config/types';\nimport type { PlayingMode } from 'modes/playing/config/types';\n\n/**\n * If a player is allowed to move in playing mode.\n * This allows for slight differences between playing and\n * playing with premoves mode - namely, the ability to move\n * when it is not the user's turn.\n */\nexport function isAllowedToMoveInPlayingMode({\n  api,\n  canMoveWhenNotPlayerTurn,\n  modeOptions,\n}: {\n  api: API.ExtendedAPI;\n  canMoveWhenNotPlayerTurn: boolean;\n  modeOptions: Modes.Options.Exposed.Model<PlayingMode.Options>;\n}): boolean {\n  const { canAddMovesToMainLine, canMoveWhenGameIsOver, canModifyExistingMovesOnMainLine } =\n    modeOptions;\n\n  return Boolean(\n    (canMoveWhenGameIsOver || !api.isGameOver()) &&\n      ((canAddMovesToMainLine && api.isAtEndOfLine()) || canModifyExistingMovesOnMainLine) &&\n      (canMoveWhenNotPlayerTurn || api.getPlayingAs() === api.getTurn()),\n  );\n}\n","import { createPlayingModePlugin } from 'modes/playing/plugin';\nimport { Modes } from 'modes/config/types';\nimport { isAllowedToMoveInPlayingMode } from 'modes/playing/model/is-allowed-to-move-in-playing-mode';\nimport { createHandleIllegalMove } from 'chessboard/model/modes/handle-illegal-move';\nimport type { PlayingMode } from 'modes/playing/config/types';\n\n/**\n * Create the base Playing mode.\n */\nexport function base({ api }: Modes.CreateMode.BaseOptions<PlayingMode.Options>): Modes.API.Base {\n  return {\n    handleIllegalMove: createHandleIllegalMove(api),\n    isAllowedToMove,\n    name: Modes.Types.Playing,\n    plugins: [createPlayingModePlugin()],\n    overridableMethods: ['isAllowedToMove'],\n    usePlayingAs: true,\n  };\n\n  /**\n   * Can only move if it's player's turn and they're trying to move their own piece.\n   */\n  function isAllowedToMove(): boolean {\n    return isAllowedToMoveInPlayingMode({\n      api,\n      canMoveWhenNotPlayerTurn: false,\n      modeOptions: api.getMode().getOptions(),\n    });\n  }\n}\n","import { createModeFactory } from 'chessboard/modes/model/create-mode';\nimport { base } from 'chessboard/modes/playing/base';\n\nexport const create = createModeFactory(base, {\n  canAddMovesToMainLine: { default: true, editable: true },\n  canMoveWhenGameIsOver: { default: false, editable: true },\n  canInteractWithPieces: { default: true, editable: true },\n  canModifyExistingMovesOnMainLine: { default: false, editable: true },\n});\n","import type { API } from 'api/config/types';\nimport type { Modes } from 'modes/config/types';\n\n/**\n * Extend or override a mode's api.\n */\nexport function createExtendMode(mode: Modes.API.Base, api: API.ExtendedAPI) {\n  return function extendMode(extensions: Record<string, Function>) {\n    const destroyOverrides: (Function | undefined)[] = Object.entries(extensions).map(\n      ([key, fn]) => {\n        if (!fn || !mode.overridableMethods?.includes(key)) {\n          return;\n        }\n\n        const cachedMethod = mode[key];\n\n        mode[key] = fn(mode, api);\n\n        return function destroyOverride() {\n          mode[key] = cachedMethod;\n        };\n      },\n    );\n\n    return function destroyOverride() {\n      destroyOverrides.map((fn) => fn?.());\n    };\n  };\n}\n","import type { API } from 'chessboard/api/config/types';\nimport { Core } from 'chessboard/core/config/types';\nimport { createCoreEvent } from 'chessboard/core/model/create-core-event';\nimport type { Modes } from 'modes/config/types';\nimport { createExtendMode } from 'modes/model/extend-mode';\n\ntype Model<T extends Modes.Options.Initial.Custom> = Modes.Options.Initial.Model<T>;\n\n/**\n * Build a mode.\n */\nfunction buildMode<T extends Modes.Options.Initial.Custom>({\n  base,\n  initialOptions,\n}: {\n  base: Modes.CreateMode.Base<Modes.Options.Exposed.Model<T>>;\n  initialOptions: Model<T>;\n}): Modes.CreateMode.Builder<T> {\n  return function getBoundMode(api: API.ExtendedAPI): Modes.API.Extended<T> {\n    const options = Object.keys(initialOptions).reduce(\n      (acc, key: keyof Model<T>) => {\n        acc[key] = initialOptions[key].default;\n\n        return acc;\n      },\n      {} as Modes.Options.Exposed.Model<T>,\n    );\n\n    const modeAPI = base({ api, options });\n    const extendMode = createExtendMode(modeAPI, api);\n\n    return Object.assign(modeAPI, { extendMode, getOptions, setOption });\n\n    /**\n     * Get the mode options.\n     */\n    function getOptions(): Modes.Options.Exposed.Model<T> {\n      return options;\n    }\n\n    /**\n     * Set an option, if the mode allows setting that option.\n     */\n    function setOption(key: keyof Model<T>, value: boolean) {\n      if (!initialOptions[key]?.editable) {\n        warnOptionNotEditable(key);\n        return;\n      }\n\n      options[key] = value;\n\n      api.emit(\n        Core.OptionsEvents.UpdateMode,\n        createCoreEvent(Core.OptionsEvents.UpdateMode, { [key]: value }),\n      );\n    }\n  };\n}\n\n/**\n * Create a mode, returning the mode itself and a function that enables\n * re-instantiating the mode with new options.\n */\nexport function createModeFactory<T extends Modes.Options.Initial.Custom>(\n  base: Modes.CreateMode.Base<Modes.Options.Exposed.Model<T>>,\n  defaults: Model<T>,\n) {\n  return function createMode(\n    options: Partial<Modes.Options.Exposed.Model<T>> = {},\n  ): Modes.CreateMode.Builder<T> {\n    const initialOptions = Object.keys(options).reduce((acc, key: keyof Model<T>) => {\n      if (defaults[key]?.editable) {\n        Object.assign(acc, { [key]: { default: options[key], editable: true } });\n      } else {\n        warnOptionNotEditable(key);\n      }\n\n      return acc;\n    }, defaults);\n\n    return buildMode({\n      base,\n      initialOptions,\n    });\n  };\n}\n\n/**\n * Warn the developer that an option is not editable.\n */\nfunction warnOptionNotEditable<T>(key: keyof T) {\n  //@ts-ignore\n  console.warn(`${key} is not an editable option in this mode.`); // eslint-disable-line\n}\n","import { isNode } from 'model/game/is-node';\nimport type { Game } from 'chessboard/model/game/types';\nimport type JCE from '@chesscom/js-chess-engine';\n\n/**\n * Get the ids of the move immediately following the given node,\n * in order to delete it.\n */\nexport function getIdsToDelete(node: Game.Move.Model | JCE.Line | null): JCE.Node.Model['ids'] {\n  if (isNode(node)) {\n    return { line: node.ids.line, move: node.ids.move + 1 };\n  }\n\n  return { line: 0, move: 0 };\n}\n","import type { API } from 'api/config/types';\n\n/**\n * Create mode handler for illegal moves\n */\nexport function createHandleIllegalMove(api: API.ExtendedAPI) {\n  /**\n   * If the user is browsing through the moves, we want any illegal move to send us\n   * back to the head of the line.\n   */\n  return function handleIllegalMove() {\n    if (!api.isAtEndOfLine()) {\n      api.selectLineEnd();\n    }\n  };\n}\n","import type { Game } from 'chessboard/model/game/types';\n\n/**\n * Determine if a given node is a node.\n */\nexport function isNode(\n  node: Game.Line | Game.Move.Node | Game.Move.Model | null,\n): node is Game.Move.Node {\n  return (<Game.Move.Node>node)?.ids !== undefined;\n}\n"],"names":["handleMoveOnPreviousNodeFactory","context","api","isAtEndOfLine","getMode","getOptions","canModifyExistingMovesOnMainLine","line","move","getIdsToDelete","getRelativeNode","deletePosition","selectLineEnd","PlayingMode","createBeforeMoveLogic","handleMoveOnPreviousNode","isGameOver","canMoveWhenGameIsOver","setResult","Game","Results","None","createPlayingModePlugin","apiOverrides","handler","run","order","name","Plugin","Name","PlayingMode2","Plugin2","isAllowedToMoveInPlayingMode","canMoveWhenNotPlayerTurn","modeOptions","canAddMovesToMainLine","Boolean","getPlayingAs","getTurn","base","handleIllegalMove","createHandleIllegalMove","isAllowedToMove","Modes","Types","Playing","plugins","overridableMethods","usePlayingAs","create","createModeFactory","default","editable","canInteractWithPieces","createExtendMode","mode","extensions","destroyOverrides","Object","entries","map","key","fn","_a","includes","cachedMethod","buildMode","initialOptions","options","keys","reduce","acc","modeAPI","extendMode","assign","setOption","value","emit","Core","OptionsEvents","UpdateMode","createCoreEvent","warnOptionNotEditable","defaults","console","warn","node","isNode","ids"],"sourceRoot":""}