{"version":3,"file":"js/8.150f57ec.js","mappings":"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","sources":["webpack://opening-quiz/../../src/chessboard/modes/guess-the-move/config/types.ts","webpack://opening-quiz/../../src/chessboard/modes/guess-the-move/api/index.ts","webpack://opening-quiz/../../src/chessboard/modes/guess-the-move/api-overrides/move.ts","webpack://opening-quiz/../../src/chessboard/modes/guess-the-move/model/highlights.ts","webpack://opening-quiz/../../src/chessboard/modes/guess-the-move/plugin/index.ts","webpack://opening-quiz/../../src/chessboard/modes/guess-the-move/base.ts","webpack://opening-quiz/../../src/chessboard/modes/guess-the-move/index.ts","webpack://opening-quiz/../../src/chessboard/modes/model/extend-mode.ts","webpack://opening-quiz/../../src/chessboard/modes/model/create-mode.ts","webpack://opening-quiz/../../src/chessboard/model/modes/handle-illegal-move.ts"],"sourcesContent":["import type { Game } from 'chessboard/model/game/types';\nimport type { Modes } from 'chessboard/modes/config/types';\n\nexport namespace GuessTheMoveMode {\n  export namespace Plugin {\n    export const Name = 'guessTheMove';\n  }\n\n  export interface API {\n    cancel: () => void;\n    confirm: (correct: boolean) => void;\n    get: () => Guess[];\n    getActiveGuess: () => Guess | undefined;\n    guess: (move: Game.Move.Model) => void;\n    reset: () => void;\n  }\n\n  export enum APIEvents {\n    CancelGuess = 'CancelGuess',\n    GuessConfirmed = 'GuessConfirmed',\n    GuessMade = 'GuessMade',\n  }\n\n  export const enum Colors {\n    Correct = '#96bc4b',\n    Incorrect = '#c93430',\n  }\n\n  export interface Guess extends Game.Move.Model {\n    correct: boolean;\n    confirmed: boolean;\n    ids: Game.Move.Node['ids'];\n  }\n\n  export interface PublicAPI {\n    [Modes.Types.GuessTheMove]: API;\n  }\n}\n","import type { API } from 'api/config/types';\nimport { Core } from 'chessboard/core/config/types';\nimport type { Game } from 'chessboard/model/game/types';\nimport { GuessTheMoveMode } from 'chessboard/modes/guess-the-move/config/types';\n\n/**\n * Create the Guess The Move API.\n */\nexport function createGuessTheMoveAPI(context: API.Context): GuessTheMoveMode.API {\n  let guesses: GuessTheMoveMode.Guess[] = [];\n\n  return {\n    cancel,\n    confirm,\n    get,\n    getActiveGuess,\n    guess,\n    reset,\n  };\n\n  /**\n   * Cancel the current active guess.\n   */\n  function cancel(): void {\n    const { api, respond } = context;\n\n    const activeGuess = getActiveGuess();\n\n    if (!activeGuess) {\n      return;\n    }\n\n    guesses.pop();\n\n    respond(Core.APIEvents.SetBoardPosition, { pieces: api.getPieces() });\n    respond(GuessTheMoveMode.APIEvents.CancelGuess, activeGuess);\n  }\n\n  /**\n   * Confirm the last guess.\n   */\n  function confirm(correct: boolean): void {\n    const { respond } = context;\n\n    const lastGuess = getLastGuess();\n\n    if (!lastGuess) {\n      return;\n    }\n\n    Object.assign(lastGuess, { confirmed: true, correct });\n\n    respond(GuessTheMoveMode.APIEvents.GuessConfirmed, lastGuess);\n  }\n\n  /**\n   * Get all guesses.\n   */\n  function get(): GuessTheMoveMode.Guess[] {\n    return guesses;\n  }\n\n  /**\n   * Get the current active guess.\n   */\n  function getActiveGuess(): GuessTheMoveMode.Guess | undefined {\n    const lastGuess = getLastGuess();\n\n    return !lastGuess?.confirmed ? lastGuess : undefined;\n  }\n\n  /**\n   * Get the last guess.\n   */\n  function getLastGuess(): GuessTheMoveMode.Guess | undefined {\n    return guesses[guesses.length - 1];\n  }\n\n  /**\n   * Make a guess.\n   */\n  function guess(move: Game.Move.Model): void {\n    const { api, respond } = context;\n\n    const newGuess: GuessTheMoveMode.Guess = {\n      ...move,\n      confirmed: false,\n      correct: false,\n      ids: api.getSelectedNode()?.ids ?? { line: 0, move: 0 },\n    };\n\n    guesses.push(newGuess);\n\n    respond(GuessTheMoveMode.APIEvents.GuessMade, newGuess);\n  }\n\n  /**\n   * Reset the guesses.\n   */\n  function reset() {\n    guesses = [];\n  }\n}\n","import { formatAPIMove } from 'api/move/model/format-api-move';\nimport type { API } from 'chessboard/api/config/types';\nimport { Core } from 'chessboard/core/config/types';\nimport type { Game } from 'chessboard/model/game/types';\n\n/**\n * Create the move override function.\n */\nexport function createMove(context: API.Context): API.ExtendedAPI['move'] {\n  const { api, game, respond } = context;\n  const originalMethod = api.move;\n\n  /**\n   * Override the move method. This handles both a move on the board for the\n   * game in progress, and a user's guess.\n   */\n  return function move(mv: API.Options.Move | string) {\n    const formattedMove = formatAPIMove(mv, api.getFEN(), api.getVariant());\n\n    if (!formattedMove) {\n      return respond(Core.APIEvents.IllegalMove);\n    }\n\n    if (!formattedMove.userGenerated) {\n      return handleGameMoveAndConfirmGuess(formattedMove);\n    }\n\n    return handleGuessAttempt(formattedMove);\n  };\n\n  /**\n   * Respond to a move in the actual game by making the move\n   * and scoring the active guess.\n   */\n  function handleGameMoveAndConfirmGuess(mv: Game.Move.FormattedMove) {\n    const originalMv = { ...mv }; // mv is mutated when calling apiMove which affects addMoveToEndOfLine\n    const activeGuess = api.guessTheMove.getActiveGuess();\n    const apiMove = api.getMove(mv);\n\n    if (!apiMove || !activeGuess) {\n      return !api.isAtEndOfLine() ? api.addMoveToEndOfLine(originalMv) : originalMethod(mv);\n    }\n\n    const correctGuess = apiMove.color === api.getPlayingAs() && apiMove.san === activeGuess.san;\n\n    // If the guess was correct, we don't want to animate since the board will\n    // already be in the correct position.\n    mv.animate = !correctGuess;\n\n    api.reload();\n\n    originalMethod(mv);\n\n    return api.guessTheMove.confirm(correctGuess);\n  }\n\n  /**\n   * Respond to a guess attempt.\n   */\n  function handleGuessAttempt(mv: Game.Move.FormattedMove) {\n    if (api.isLegalMove(mv)) {\n      const guess = game.move(mv);\n\n      if (!guess) {\n        return respond(Core.APIEvents.IllegalMove);\n      }\n\n      api.guessTheMove.guess(guess);\n\n      const pieces = { ...api.getPieces() };\n\n      game.undo();\n\n      return respond(Core.APIEvents.SetBoardPosition, { pieces });\n    }\n\n    return respond(Core.APIEvents.IllegalMove);\n  }\n}\n","import type { API } from 'chessboard/api/config/types';\nimport type { Board } from 'chessboard/model/board/types';\nimport { createKeyedHighlight } from 'chessboard/plugins/highlights/model/create-keyed-highlight';\nimport type { Core } from 'chessboard/core/config/types';\nimport type { KeyedHighlight } from 'chessboard/plugins/highlights/config/types';\nimport { nodeTargetSquare } from 'api/move/model/node-target-square';\n\nexport const GTMHighlight = 'gtm';\n\n/**\n * Gets GTM highlights from the API.\n */\nexport function getGuessTheMoveHighlights(\n  _event: Core.Event,\n  context: Core.Context,\n): KeyedHighlight[] {\n  const { api, options }: { api: API.ExtendedAPI; options: Board.Options } = context;\n\n  const activeGuess = api.guessTheMove?.getActiveGuess();\n\n  if (!options || !options.allowMarkings || !activeGuess) {\n    return [];\n  }\n\n  const highlights: KeyedHighlight[] = [];\n\n  if (activeGuess.from) {\n    const fromHighlight = createKeyedHighlight({\n      color: options.premoveHighlightColor,\n      opacity: options.premoveHighlightOpacity,\n      square: <Board.SanSquare>activeGuess.from,\n      type: GTMHighlight,\n    });\n\n    highlights.push(fromHighlight);\n  }\n\n  const toHighlight = createKeyedHighlight({\n    color: options.premoveHighlightColor,\n    opacity: options.premoveHighlightOpacity,\n    square: nodeTargetSquare(activeGuess),\n    type: GTMHighlight,\n  });\n\n  highlights.push(toHighlight);\n\n  return highlights;\n}\n","import { Core } from 'chessboard/core/config/types';\nimport { createGuessTheMoveAPI } from 'chessboard/modes/guess-the-move/api';\nimport { createMove } from 'chessboard/modes/guess-the-move/api-overrides/move';\nimport { getGuessTheMoveHighlights } from 'chessboard/modes/guess-the-move/model/highlights';\nimport { GuessTheMoveMode } from 'modes/guess-the-move/config/types';\nimport { isOneOf } from 'src/utils/app/model/is-one-of';\nimport type { Plugins } from 'chessboard/core/plugins/config/types';\nimport { positionChangeEvents } from 'chessboard/config/position-change-events';\nimport { is } from 'src/utils/app/model/is';\n\n/**\n * Create the Guess the Move plugin.\n */\nexport function createGuessTheMoveModePlugin(): Plugins.Model {\n  let hasHighlights = false;\n\n  return {\n    api: createGuessTheMoveAPI,\n    apiOverrides: {\n      move: createMove,\n    },\n    beforeState: [\n      {\n        condition: is(Core.UserEvents.PointerdownRight),\n        handler: cancelGuess,\n      },\n    ],\n    destroy,\n    match: [\n      {\n        condition: isOneOf(positionChangeEvents),\n        handler,\n      },\n      {\n        condition: isOneOf(GuessTheMoveMode.APIEvents),\n        handler: addHighlights,\n      },\n      {\n        condition: is(GuessTheMoveMode.APIEvents.GuessConfirmed),\n        handler: handleGuessConfirmation,\n      },\n    ],\n    name: GuessTheMoveMode.Plugin.Name,\n  };\n\n  /**\n   * Ensure the highlights module has been added.\n   */\n  function addHighlights(_event: Core.Event, context: Core.Context) {\n    if (hasHighlights) {\n      return;\n    }\n\n    const { api } = context;\n\n    api.highlights?.addModule(getGuessTheMoveHighlights);\n\n    if (\n      (api.highlights?.getModules() ?? []).find((mod) => mod.name === 'getGuessTheMoveHighlights')\n    ) {\n      hasHighlights = true;\n    }\n  }\n\n  /**\n   * Cancel the guess and tell the state machine to ignore the event,\n   * so the square will not be highlighted.\n   */\n  function cancelGuess(_event: Core.Event, { api, queue }: Core.Context): boolean {\n    if (!api.guessTheMove.getActiveGuess()) {\n      return true;\n    }\n\n    queue.add(api.guessTheMove.cancel);\n\n    return false;\n  }\n\n  /**\n   * Destroy the plugin and remove highlights module.\n   */\n  function destroy(context: Core.Context) {\n    const { api } = context;\n\n    api.highlights?.removeModule(getGuessTheMoveHighlights);\n  }\n\n  /**\n   * Mark the confirmed guess with the color corresponding to\n   * a correct or incorrect guess.\n   */\n  function handleGuessConfirmation(event: Core.Event, context: Core.Context) {\n    const { api } = context;\n    const { correct, ids } = event.data;\n\n    api.updateNode(ids, {\n      customColor: correct ? GuessTheMoveMode.Colors.Correct : GuessTheMoveMode.Colors.Incorrect,\n    });\n  }\n\n  /**\n   * Handle a position change event.\n   */\n  function handler(event: Core.Event, context: Core.Context) {\n    const { api, queue } = context;\n\n    if (event.type === Core.APIEvents.Load) {\n      api.guessTheMove.reset();\n    }\n\n    // Ensure user is always playing as the side to move.\n    const turn = api.getTurn();\n\n    queue.add(api.setPlayingAs, turn);\n  }\n}\n","import { Modes } from 'chessboard/modes/config/types';\nimport { createGuessTheMoveModePlugin } from 'modes/guess-the-move/plugin';\nimport { createHandleIllegalMove } from 'chessboard/model/modes/handle-illegal-move';\n\n/**\n * Create the base observing mode.\n */\nexport function base({ api }: Modes.CreateMode.BaseOptions): Modes.API.Base {\n  return {\n    isAllowedToMove,\n    handleIllegalMove: createHandleIllegalMove(api),\n    name: Modes.Types.GuessTheMove,\n    plugins: [createGuessTheMoveModePlugin()],\n    usePlayingAs: true,\n  };\n\n  /**\n   * Is allowed to move\n   */\n  function isAllowedToMove(): boolean {\n    return api.guessTheMove && api.isAtEndOfLine() && !api.guessTheMove.getActiveGuess();\n  }\n}\n","import { createModeFactory } from 'chessboard/modes/model/create-mode';\nimport { base } from 'chessboard/modes/guess-the-move/base';\n\nexport const create = createModeFactory(base, {\n  canAddMovesToMainLine: { default: true, editable: false },\n  canInteractWithPieces: { default: true, editable: true },\n  canModifyExistingMovesOnMainLine: { default: false, editable: false },\n});\n","import type { API } from 'api/config/types';\nimport type { Modes } from 'modes/config/types';\n\n/**\n * Extend or override a mode's api.\n */\nexport function createExtendMode(mode: Modes.API.Base, api: API.ExtendedAPI) {\n  return function extendMode(extensions: Record<string, Function>) {\n    const destroyOverrides: (Function | undefined)[] = Object.entries(extensions).map(\n      ([key, fn]) => {\n        if (!fn || !mode.overridableMethods?.includes(key)) {\n          return;\n        }\n\n        const cachedMethod = mode[key];\n\n        mode[key] = fn(mode, api);\n\n        return function destroyOverride() {\n          mode[key] = cachedMethod;\n        };\n      },\n    );\n\n    return function destroyOverride() {\n      destroyOverrides.map((fn) => fn?.());\n    };\n  };\n}\n","import type { API } from 'chessboard/api/config/types';\nimport { Core } from 'chessboard/core/config/types';\nimport { createCoreEvent } from 'chessboard/core/model/create-core-event';\nimport type { Modes } from 'modes/config/types';\nimport { createExtendMode } from 'modes/model/extend-mode';\n\ntype Model<T extends Modes.Options.Initial.Custom> = Modes.Options.Initial.Model<T>;\n\n/**\n * Build a mode.\n */\nfunction buildMode<T extends Modes.Options.Initial.Custom>({\n  base,\n  initialOptions,\n}: {\n  base: Modes.CreateMode.Base<Modes.Options.Exposed.Model<T>>;\n  initialOptions: Model<T>;\n}): Modes.CreateMode.Builder<T> {\n  return function getBoundMode(api: API.ExtendedAPI): Modes.API.Extended<T> {\n    const options = Object.keys(initialOptions).reduce(\n      (acc, key: keyof Model<T>) => {\n        acc[key] = initialOptions[key].default;\n\n        return acc;\n      },\n      {} as Modes.Options.Exposed.Model<T>,\n    );\n\n    const modeAPI = base({ api, options });\n    const extendMode = createExtendMode(modeAPI, api);\n\n    return Object.assign(modeAPI, { extendMode, getOptions, setOption });\n\n    /**\n     * Get the mode options.\n     */\n    function getOptions(): Modes.Options.Exposed.Model<T> {\n      return options;\n    }\n\n    /**\n     * Set an option, if the mode allows setting that option.\n     */\n    function setOption(key: keyof Model<T>, value: boolean) {\n      if (!initialOptions[key]?.editable) {\n        warnOptionNotEditable(key);\n        return;\n      }\n\n      options[key] = value;\n\n      api.emit(\n        Core.OptionsEvents.UpdateMode,\n        createCoreEvent(Core.OptionsEvents.UpdateMode, { [key]: value }),\n      );\n    }\n  };\n}\n\n/**\n * Create a mode, returning the mode itself and a function that enables\n * re-instantiating the mode with new options.\n */\nexport function createModeFactory<T extends Modes.Options.Initial.Custom>(\n  base: Modes.CreateMode.Base<Modes.Options.Exposed.Model<T>>,\n  defaults: Model<T>,\n) {\n  return function createMode(\n    options: Partial<Modes.Options.Exposed.Model<T>> = {},\n  ): Modes.CreateMode.Builder<T> {\n    const initialOptions = Object.keys(options).reduce((acc, key: keyof Model<T>) => {\n      if (defaults[key]?.editable) {\n        Object.assign(acc, { [key]: { default: options[key], editable: true } });\n      } else {\n        warnOptionNotEditable(key);\n      }\n\n      return acc;\n    }, defaults);\n\n    return buildMode({\n      base,\n      initialOptions,\n    });\n  };\n}\n\n/**\n * Warn the developer that an option is not editable.\n */\nfunction warnOptionNotEditable<T>(key: keyof T) {\n  //@ts-ignore\n  console.warn(`${key} is not an editable option in this mode.`); // eslint-disable-line\n}\n","import type { API } from 'api/config/types';\n\n/**\n * Create mode handler for illegal moves\n */\nexport function createHandleIllegalMove(api: API.ExtendedAPI) {\n  /**\n   * If the user is browsing through the moves, we want any illegal move to send us\n   * back to the head of the line.\n   */\n  return function handleIllegalMove() {\n    if (!api.isAtEndOfLine()) {\n      api.selectLineEnd();\n    }\n  };\n}\n"],"names":["GuessTheMoveMode","createGuessTheMoveAPI","context","guesses","cancel","confirm","get","getActiveGuess","guess","reset","api","respond","activeGuess","pop","Core","APIEvents","SetBoardPosition","pieces","getPieces","CancelGuess","correct","lastGuess","getLastGuess","Object","assign","confirmed","GuessConfirmed","length","move","newGuess","ids","_a","getSelectedNode","line","push","GuessMade","GuessTheMoveMode2","Plugin2","Name","Plugin","APIEvents2","Colors2","Colors","createMove","game","originalMethod","mv","formattedMove","formatAPIMove","getFEN","getVariant","userGenerated","handleGuessAttempt","handleGameMoveAndConfirmGuess","IllegalMove","originalMv","guessTheMove","apiMove","getMove","isAtEndOfLine","addMoveToEndOfLine","correctGuess","color","getPlayingAs","san","animate","reload","isLegalMove","undo","GTMHighlight","getGuessTheMoveHighlights","_event","options","allowMarkings","highlights","from","fromHighlight","createKeyedHighlight","premoveHighlightColor","opacity","premoveHighlightOpacity","square","type","toHighlight","nodeTargetSquare","createGuessTheMoveModePlugin","hasHighlights","apiOverrides","beforeState","condition","is","UserEvents","PointerdownRight","handler","cancelGuess","destroy","match","isOneOf","positionChangeEvents","addHighlights","handleGuessConfirmation","name","addModule","_b","getModules","find","mod","queue","add","removeModule","event","data","updateNode","customColor","Correct","Incorrect","Load","turn","getTurn","setPlayingAs","base","isAllowedToMove","handleIllegalMove","createHandleIllegalMove","Modes","Types","GuessTheMove","plugins","usePlayingAs","create","createModeFactory","canAddMovesToMainLine","default","editable","canInteractWithPieces","canModifyExistingMovesOnMainLine","createExtendMode","mode","extensions","destroyOverrides","entries","map","key","fn","overridableMethods","includes","cachedMethod","buildMode","initialOptions","keys","reduce","acc","modeAPI","extendMode","getOptions","setOption","value","emit","OptionsEvents","UpdateMode","createCoreEvent","warnOptionNotEditable","defaults","console","warn","selectLineEnd"],"sourceRoot":""}