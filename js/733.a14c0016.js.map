{"version":3,"file":"js/733.a14c0016.js","mappings":"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","sources":["webpack://opening-quiz/../../src/chessboard/modes/model/extend-mode.ts","webpack://opening-quiz/../../src/chessboard/modes/model/create-mode.ts","webpack://opening-quiz/../../src/chessboard/model/game/can-move-forward.ts","webpack://opening-quiz/../../src/chessboard/modes/analysis/model/should-add-continuation.ts","webpack://opening-quiz/../../src/chessboard/modes/analysis/config/types.ts","webpack://opening-quiz/../../src/chessboard/modes/analysis/api-overrides/move.ts","webpack://opening-quiz/../../src/chessboard/modes/analysis/plugin/index.ts","webpack://opening-quiz/../../src/chessboard/modes/analysis/base.ts","webpack://opening-quiz/../../src/chessboard/modes/analysis/index.ts","webpack://opening-quiz/../../src/chessboard/plugins/analysis-overlay/config/types.ts","webpack://opening-quiz/../../src/chessboard/plugins/analysis-overlay/index.ts"],"sourcesContent":["import type { API } from 'api/config/types';\nimport type { Modes } from 'modes/config/types';\n\n/**\n * Extend or override a mode's api.\n */\nexport function createExtendMode(mode: Modes.API.Base, api: API.ExtendedAPI) {\n  return function extendMode(extensions: Record<string, Function>) {\n    const destroyOverrides: (Function | undefined)[] = Object.entries(extensions).map(\n      ([key, fn]) => {\n        if (!fn || !mode.overridableMethods?.includes(key)) {\n          return;\n        }\n\n        const cachedMethod = mode[key];\n\n        mode[key] = fn(mode, api);\n\n        return function destroyOverride() {\n          mode[key] = cachedMethod;\n        };\n      },\n    );\n\n    return function destroyOverride() {\n      destroyOverrides.map((fn) => fn?.());\n    };\n  };\n}\n","import type { API } from 'chessboard/api/config/types';\nimport { Core } from 'chessboard/core/config/types';\nimport { createCoreEvent } from 'chessboard/core/model/create-core-event';\nimport type { Modes } from 'modes/config/types';\nimport { createExtendMode } from 'modes/model/extend-mode';\n\ntype Model<T extends Modes.Options.Initial.Custom> = Modes.Options.Initial.Model<T>;\n\n/**\n * Build a mode.\n */\nfunction buildMode<T extends Modes.Options.Initial.Custom>({\n  base,\n  initialOptions,\n}: {\n  base: Modes.CreateMode.Base<Modes.Options.Exposed.Model<T>>;\n  initialOptions: Model<T>;\n}): Modes.CreateMode.Builder<T> {\n  return function getBoundMode(api: API.ExtendedAPI): Modes.API.Extended<T> {\n    const options = Object.keys(initialOptions).reduce(\n      (acc, key: keyof Model<T>) => {\n        acc[key] = initialOptions[key].default;\n\n        return acc;\n      },\n      {} as Modes.Options.Exposed.Model<T>,\n    );\n\n    const modeAPI = base({ api, options });\n    const extendMode = createExtendMode(modeAPI, api);\n\n    return Object.assign(modeAPI, { extendMode, getOptions, setOption });\n\n    /**\n     * Get the mode options.\n     */\n    function getOptions(): Modes.Options.Exposed.Model<T> {\n      return options;\n    }\n\n    /**\n     * Set an option, if the mode allows setting that option.\n     */\n    function setOption(key: keyof Model<T>, value: boolean) {\n      if (!initialOptions[key]?.editable) {\n        warnOptionNotEditable(key);\n        return;\n      }\n\n      options[key] = value;\n\n      api.emit(\n        Core.OptionsEvents.UpdateMode,\n        createCoreEvent(Core.OptionsEvents.UpdateMode, { [key]: value }),\n      );\n    }\n  };\n}\n\n/**\n * Create a mode, returning the mode itself and a function that enables\n * re-instantiating the mode with new options.\n */\nexport function createModeFactory<T extends Modes.Options.Initial.Custom>(\n  base: Modes.CreateMode.Base<Modes.Options.Exposed.Model<T>>,\n  defaults: Model<T>,\n) {\n  return function createMode(\n    options: Partial<Modes.Options.Exposed.Model<T>> = {},\n  ): Modes.CreateMode.Builder<T> {\n    const initialOptions = Object.keys(options).reduce((acc, key: keyof Model<T>) => {\n      if (defaults[key]?.editable) {\n        Object.assign(acc, { [key]: { default: options[key], editable: true } });\n      } else {\n        warnOptionNotEditable(key);\n      }\n\n      return acc;\n    }, defaults);\n\n    return buildMode({\n      base,\n      initialOptions,\n    });\n  };\n}\n\n/**\n * Warn the developer that an option is not editable.\n */\nfunction warnOptionNotEditable<T>(key: keyof T) {\n  //@ts-ignore\n  console.warn(`${key} is not an editable option in this mode.`); // eslint-disable-line\n}\n","import type { API } from 'api/config/types';\nimport type { Game } from 'chessboard/model/game/types';\n\n/**\n * Determine whether a move can move forward on the same line\n */\nexport function canMoveForward({\n  api,\n  followAlternateLines = false,\n  mv,\n}: {\n  api: API.ExtendedAPI;\n  followAlternateLines?: boolean;\n  mv: Game.Move.FormattedMove;\n}): boolean {\n  const { game, mutateGame } = api.getContext();\n\n  const data = mutateGame(function callMethod() {\n    game.moveForward(followAlternateLines, mv);\n  });\n\n  if (!data?.plyDiff) {\n    return false;\n  }\n\n  game.moveBackward();\n\n  return true;\n}\n","import { isNode } from 'chessboard/model/game/is-node';\nimport type { Game } from 'chessboard/model/game/types';\nimport type JCE from '@chesscom/js-chess-engine';\n\n/**\n * Check to see if a continuation should be added.\n */\nexport function shouldAddContinuation({\n  canAddMovesToMainLine,\n  isAtEndOfLine,\n  node,\n}: {\n  canAddMovesToMainLine: boolean;\n  isAtEndOfLine: boolean;\n  node: Game.Move.Node | JCE.Line | null;\n}): boolean {\n  const line = isNode(node) ? node?.ids?.line : node?.id;\n\n  return !canAddMovesToMainLine && isAtEndOfLine && line === 0;\n}\n","import type { Modes } from 'modes/config/types';\n\nexport namespace AnalysisMode {\n  export type Options = {\n    usePlayingAs: Modes.Options.Initial.Option;\n  };\n\n  export namespace Plugin {\n    export const Name = 'analysis';\n  }\n}\n","import type { API } from 'src';\nimport { canMoveForward } from 'chessboard/model/game/can-move-forward';\nimport { shouldAddContinuation } from 'modes/analysis/model/should-add-continuation';\nimport { formatAPIMove } from 'api/move/model/format-api-move';\n\n/**\n * Override the move function, creating a variation or continuation as needed.\n */\nexport function createMove(context: API.Context) {\n  const { api } = context;\n  const originalMethod = api.move;\n\n  return function move(mv: API.Options.Move | string): API.Response {\n    const formattedMove = formatAPIMove(mv, api.getFEN(), api.getVariant());\n\n    // if the move can't be formatted, then just pass it to the original method.\n    if (!formattedMove) {\n      return originalMethod(mv);\n    }\n\n    const isAtEndOfLine = api.isAtEndOfLine();\n    const { canAddMovesToMainLine } = api.getMode().getOptions();\n\n    if (canMoveForward({ api, followAlternateLines: true, mv: formattedMove })) {\n      return originalMethod(mv);\n    }\n\n    if (\n      shouldAddContinuation({\n        canAddMovesToMainLine,\n        isAtEndOfLine,\n        node: api.getRelativeNode(),\n      })\n    ) {\n      return addContinuation();\n    }\n\n    return originalMethod(mv);\n\n    /**\n     * Create a continuation and make a move if it succeeded.\n     */\n    function addContinuation() {\n      const continuationSucceeded = api.createContinuation();\n\n      if (continuationSucceeded) {\n        return originalMethod(mv);\n      }\n\n      return null;\n    }\n  };\n}\n","import { Core } from 'chessboard/core/config/types';\nimport type { Plugins } from 'chessboard/core/plugins/config/types';\nimport { createMove } from 'modes/analysis/api-overrides/move';\nimport { AnalysisMode } from 'modes/analysis/config/types';\nimport { is } from 'src/utils/app/model/is';\n\n/**\n * Create a factory for the analysis mode's plugin.\n */\nexport function createAnalysisModePlugin(): Plugins.Model {\n  return {\n    apiOverrides: {\n      move: createMove,\n    },\n    match: [\n      {\n        condition: is(Core.OptionsEvents.UpdateMode),\n        handler: changeUsePlayingAs,\n      },\n    ],\n    name: AnalysisMode.Plugin.Name,\n  };\n\n  /**\n   * Update the usePlayingAs game option based on change of the mode option\n   * */\n  function changeUsePlayingAs(event: Core.Event, { api }: Core.Context) {\n    if (event.data.usePlayingAs !== undefined) {\n      api.usePlayingAs(event.data.usePlayingAs);\n    }\n  }\n}\n","import { createAnalysisOverlayPlugin } from 'chessboard/plugins/analysis-overlay';\nimport { createAnalysisModePlugin } from 'chessboard/modes/analysis/plugin';\nimport { Modes } from 'modes/config/types';\nimport type { AnalysisMode } from 'modes/analysis/config/types';\n\n/**\n * Create an analysis mode, bound to the API.\n */\nexport function base({\n  api,\n  options,\n}: Modes.CreateMode.BaseOptions<AnalysisMode.Options>): Modes.API.Base {\n  return {\n    isAllowedToMove,\n    name: Modes.Types.Analysis,\n    plugins: [createAnalysisModePlugin(), createAnalysisOverlayPlugin()],\n    usePlayingAs: options.usePlayingAs,\n  };\n\n  /**\n   * Can move for both sides or only one when usePlayingAs is set.\n   */\n  function isAllowedToMove() {\n    const { canAddMovesToMainLine } = api.getMode().getOptions();\n    const playingAs = api.getPlayingAs();\n\n    return (\n      (playingAs === undefined || playingAs === api.getTurn()) &&\n      (canAddMovesToMainLine || Boolean(api.getSelectedNode()) || api.getLine(0)?.length)\n    );\n  }\n}\n","import { createModeFactory } from 'chessboard/modes/model/create-mode';\nimport { base } from 'chessboard/modes/analysis/base';\n\nexport const create = createModeFactory(base, {\n  canAddMovesToMainLine: { default: true, editable: true },\n  canInteractWithPieces: { default: true, editable: true },\n  canMoveWhenGameIsOver: { default: true, editable: false },\n  canModifyExistingMovesOnMainLine: { default: true, editable: true },\n  usePlayingAs: { default: false, editable: true },\n});\n","export namespace AnalysisOverlay {\n  export namespace Plugin {\n    export const Name = 'analysis-overlay';\n  }\n}\n","import { AnalysisOverlay } from 'chessboard/plugins/analysis-overlay/config/types';\nimport { Core } from 'chessboard/core/config/types';\nimport { isOneOf } from 'utils/app/model/is-one-of';\nimport type { Plugins } from 'chessboard/core/plugins/config/types';\nimport type { Renderer } from 'chessboard/renderers/config/types';\n\n/**\n * Manage the display of the analysis overlay.\n */\nexport function createAnalysisOverlayPlugin(): Plugins.Model {\n  let renderer: Renderer.Model;\n\n  return {\n    destroy,\n    match: [\n      {\n        condition: isOneOf([\n          Core.APIEvents.Load,\n          Core.OptionsEvents.Update,\n          Core.InstanceEvents.ModeChanged,\n          Core.InstanceEvents.RendererSet,\n        ]),\n        handler: updateAnalysisOverlay,\n      },\n    ],\n    name: AnalysisOverlay.Plugin.Name,\n  };\n\n  /**\n   * Destroy the analysis overlay plugin.\n   */\n  function destroy() {\n    renderer?.removeAnalysisOverlay();\n  }\n\n  /**\n   * Run.\n   */\n  function updateAnalysisOverlay(_event: Core.Event, context: Core.Context) {\n    const { options, renderer: contextRenderer } = context;\n\n    if (!renderer && contextRenderer) {\n      renderer = contextRenderer;\n    }\n\n    if (options.overlayInAnalysisMode) {\n      renderer?.addAnalysisOverlay();\n    } else {\n      renderer?.removeAnalysisOverlay();\n    }\n  }\n}\n"],"names":["createExtendMode","mode","api","extensions","destroyOverrides","Object","entries","map","key","fn","_a","overridableMethods","includes","cachedMethod","buildMode","base","initialOptions","options","keys","reduce","acc","default","modeAPI","extendMode","assign","getOptions","setOption","value","editable","emit","Core","OptionsEvents","UpdateMode","createCoreEvent","warnOptionNotEditable","createModeFactory","defaults","console","warn","canMoveForward","followAlternateLines","mv","game","mutateGame","getContext","data","moveForward","plyDiff","moveBackward","shouldAddContinuation","canAddMovesToMainLine","isAtEndOfLine","node","line","isNode","ids","id","AnalysisMode","createMove","context","originalMethod","move","formattedMove","formatAPIMove","getFEN","getVariant","getMode","getRelativeNode","addContinuation","continuationSucceeded","createContinuation","AnalysisMode2","Plugin2","Name","Plugin","createAnalysisModePlugin","apiOverrides","match","condition","is","handler","changeUsePlayingAs","name","event","usePlayingAs","isAllowedToMove","Modes","Types","Analysis","plugins","createAnalysisOverlayPlugin","playingAs","getPlayingAs","getTurn","Boolean","getSelectedNode","getLine","length","create","canInteractWithPieces","canMoveWhenGameIsOver","canModifyExistingMovesOnMainLine","AnalysisOverlay","AnalysisOverlay2","renderer","destroy","isOneOf","APIEvents","Load","Update","InstanceEvents","ModeChanged","RendererSet","updateAnalysisOverlay","removeAnalysisOverlay","_event","contextRenderer","overlayInAnalysisMode","addAnalysisOverlay"],"sourceRoot":""}